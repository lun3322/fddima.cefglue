<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
void GenerateProxyClasses()
{
#>//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using CefGlue.Interop;
    using CefGlue.Diagnostics;
<#+ foreach (var handler in this.ProxySchema.Values) {
        GenerateProxyClass(handler);
    } #>
}

<#+
}

void GenerateProxyClass(ProxyDef def)
{
    def.ApplyMethodIndexes();
#>

    public sealed unsafe partial class <#=def.ClassName#> : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create <#=def.ClassName#> proxy from pointer.
        /// </summary>
        internal static <#=def.ClassName#> From(<#=def.StructName#>* ptr)
        {
            return new <#=def.ClassName#>(ptr);
        }

        internal static <#=def.ClassName#> FromOrDefault(<#=def.StructName#>* ptr)
        {
            if (ptr == null) return null;
            return new <#=def.ClassName#>(ptr);
        }

        private <#=def.StructName#>* ptr;

        private <#=def.ClassName#>(<#=def.StructName#>* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~<#=def.ClassName#>()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion

<#+
    if (def.GenerateMethodAccessors)
    {
        GenerateMethodAccessor("add_ref", "cef_base_t.add_ref_delegate", "this.ptr->@base.add_ref", 0);
        GenerateMethodAccessor("release", "cef_base_t.release_delegate", "this.ptr->@base.release", 1);
        GenerateMethodAccessor("get_refct", "cef_base_t.get_refct_delegate", "this.ptr->@base.get_refct", 2);
    }
#>

        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return <#=def.StructName#>.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return <#=def.StructName#>.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return <#=def.StructName#>.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal <#=def.StructName#>* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal <#=def.StructName#>* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

<#+ 
    if (def.GenerateMethodAccessors)
    {
        foreach (var method in def.GetMethods())
        {
            GenerateMethodAccessor(method);
        }
    }
#>
    }
<#+
}

void GenerateMethodAccessor(ProxyMethodDef method)
{
    GenerateMethodAccessor(method.StructName, method.NativeDelegateType, "this.ptr->" + method.StructName, method.Index);
}

void GenerateMethodAccessor(string structName, string nativeDelegateType, string pointerExpr, int index)
{
    // This is assumes, that underlying type have one implementation, i.e. method pointers in fact is non virtual and do not changed from object to object.

    var bsPtr0 = "sp" + Convert.ToString(index, 16);
    var bsDelegate0 = "sd" + Convert.ToString(index, 16);
#>

        private static IntPtr <#=bsPtr0#>;
        private static <#=nativeDelegateType#> <#=bsDelegate0#>;

        private <#=nativeDelegateType#> <#=structName#>
        {
            get
            {
                var mptr = <#=pointerExpr#>;
                if (mptr == <#=bsPtr0#>)
                {
                    return <#=bsDelegate0#>;
                }
                else
                {
                    var mdelegate = (<#=nativeDelegateType#>)Marshal.GetDelegateForFunctionPointer(mptr, typeof(<#=nativeDelegateType#>));
                    if (<#=bsPtr0#> == IntPtr.Zero)
                    {
                        <#=bsDelegate0#> = mdelegate;
                        <#=bsPtr0#> = mptr;
                    }
                    return mdelegate;
                }
            }
        }

<#+
}

#>
