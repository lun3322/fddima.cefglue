//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using Core;
    using Diagnostics;

    public sealed unsafe partial class CefBrowser : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefBrowser proxy from pointer.
        /// </summary>
        internal static CefBrowser From(cef_browser_t* ptr)
        {
            return new CefBrowser(ptr);
        }

        internal static CefBrowser FromOrDefault(cef_browser_t* ptr)
        {
            if (ptr == null) return null;
            return new CefBrowser(ptr);
        }

        private cef_browser_t* ptr;

        private CefBrowser(cef_browser_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefBrowser, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefBrowser()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefBrowser, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_browser_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_browser_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_browser_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_browser_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_browser_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefFrame : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefFrame proxy from pointer.
        /// </summary>
        internal static CefFrame From(cef_frame_t* ptr)
        {
            return new CefFrame(ptr);
        }

        internal static CefFrame FromOrDefault(cef_frame_t* ptr)
        {
            if (ptr == null) return null;
            return new CefFrame(ptr);
        }

        private cef_frame_t* ptr;

        private CefFrame(cef_frame_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefFrame, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefFrame()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefFrame, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_frame_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_frame_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_frame_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_frame_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_frame_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefRequest : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefRequest proxy from pointer.
        /// </summary>
        internal static CefRequest From(cef_request_t* ptr)
        {
            return new CefRequest(ptr);
        }

        internal static CefRequest FromOrDefault(cef_request_t* ptr)
        {
            if (ptr == null) return null;
            return new CefRequest(ptr);
        }

        private cef_request_t* ptr;

        private CefRequest(cef_request_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefRequest, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefRequest()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefRequest, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_request_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_request_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_request_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_request_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_request_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefPostData : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefPostData proxy from pointer.
        /// </summary>
        internal static CefPostData From(cef_post_data_t* ptr)
        {
            return new CefPostData(ptr);
        }

        internal static CefPostData FromOrDefault(cef_post_data_t* ptr)
        {
            if (ptr == null) return null;
            return new CefPostData(ptr);
        }

        private cef_post_data_t* ptr;

        private CefPostData(cef_post_data_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefPostData, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefPostData()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefPostData, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_post_data_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_post_data_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_post_data_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_post_data_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_post_data_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefPostDataElement : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefPostDataElement proxy from pointer.
        /// </summary>
        internal static CefPostDataElement From(cef_post_data_element_t* ptr)
        {
            return new CefPostDataElement(ptr);
        }

        internal static CefPostDataElement FromOrDefault(cef_post_data_element_t* ptr)
        {
            if (ptr == null) return null;
            return new CefPostDataElement(ptr);
        }

        private cef_post_data_element_t* ptr;

        private CefPostDataElement(cef_post_data_element_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefPostDataElement, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefPostDataElement()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefPostDataElement, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_post_data_element_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_post_data_element_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_post_data_element_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_post_data_element_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_post_data_element_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefResponse : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefResponse proxy from pointer.
        /// </summary>
        internal static CefResponse From(cef_response_t* ptr)
        {
            return new CefResponse(ptr);
        }

        internal static CefResponse FromOrDefault(cef_response_t* ptr)
        {
            if (ptr == null) return null;
            return new CefResponse(ptr);
        }

        private cef_response_t* ptr;

        private CefResponse(cef_response_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefResponse, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefResponse()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefResponse, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_response_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_response_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_response_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_response_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_response_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefStreamReader : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefStreamReader proxy from pointer.
        /// </summary>
        internal static CefStreamReader From(cef_stream_reader_t* ptr)
        {
            return new CefStreamReader(ptr);
        }

        internal static CefStreamReader FromOrDefault(cef_stream_reader_t* ptr)
        {
            if (ptr == null) return null;
            return new CefStreamReader(ptr);
        }

        private cef_stream_reader_t* ptr;

        private CefStreamReader(cef_stream_reader_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefStreamReader, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefStreamReader()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefStreamReader, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_stream_reader_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_stream_reader_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_stream_reader_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_stream_reader_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_stream_reader_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefStreamWriter : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefStreamWriter proxy from pointer.
        /// </summary>
        internal static CefStreamWriter From(cef_stream_writer_t* ptr)
        {
            return new CefStreamWriter(ptr);
        }

        internal static CefStreamWriter FromOrDefault(cef_stream_writer_t* ptr)
        {
            if (ptr == null) return null;
            return new CefStreamWriter(ptr);
        }

        private cef_stream_writer_t* ptr;

        private CefStreamWriter(cef_stream_writer_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefStreamWriter, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefStreamWriter()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefStreamWriter, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_stream_writer_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_stream_writer_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_stream_writer_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_stream_writer_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_stream_writer_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefV8Context : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefV8Context proxy from pointer.
        /// </summary>
        internal static CefV8Context From(cef_v8context_t* ptr)
        {
            return new CefV8Context(ptr);
        }

        internal static CefV8Context FromOrDefault(cef_v8context_t* ptr)
        {
            if (ptr == null) return null;
            return new CefV8Context(ptr);
        }

        private cef_v8context_t* ptr;

        private CefV8Context(cef_v8context_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefV8Context, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefV8Context()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefV8Context, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_v8context_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_v8context_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_v8context_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_v8context_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_v8context_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefV8Value : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefV8Value proxy from pointer.
        /// </summary>
        internal static CefV8Value From(cef_v8value_t* ptr)
        {
            return new CefV8Value(ptr);
        }

        internal static CefV8Value FromOrDefault(cef_v8value_t* ptr)
        {
            if (ptr == null) return null;
            return new CefV8Value(ptr);
        }

        private cef_v8value_t* ptr;

        private CefV8Value(cef_v8value_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefV8Value, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefV8Value()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefV8Value, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_v8value_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_v8value_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_v8value_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_v8value_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_v8value_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefSchemeHandlerCallback : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefSchemeHandlerCallback proxy from pointer.
        /// </summary>
        internal static CefSchemeHandlerCallback From(cef_scheme_handler_callback_t* ptr)
        {
            return new CefSchemeHandlerCallback(ptr);
        }

        internal static CefSchemeHandlerCallback FromOrDefault(cef_scheme_handler_callback_t* ptr)
        {
            if (ptr == null) return null;
            return new CefSchemeHandlerCallback(ptr);
        }

        private cef_scheme_handler_callback_t* ptr;

        private CefSchemeHandlerCallback(cef_scheme_handler_callback_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerCallback, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefSchemeHandlerCallback()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefSchemeHandlerCallback, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_scheme_handler_callback_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_scheme_handler_callback_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_scheme_handler_callback_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_scheme_handler_callback_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_scheme_handler_callback_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefWebUrlRequest : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefWebUrlRequest proxy from pointer.
        /// </summary>
        internal static CefWebUrlRequest From(cef_web_urlrequest_t* ptr)
        {
            return new CefWebUrlRequest(ptr);
        }

        internal static CefWebUrlRequest FromOrDefault(cef_web_urlrequest_t* ptr)
        {
            if (ptr == null) return null;
            return new CefWebUrlRequest(ptr);
        }

        private cef_web_urlrequest_t* ptr;

        private CefWebUrlRequest(cef_web_urlrequest_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefWebUrlRequest, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefWebUrlRequest()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefWebUrlRequest, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_web_urlrequest_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_web_urlrequest_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_web_urlrequest_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_web_urlrequest_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_web_urlrequest_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefXmlReader : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefXmlReader proxy from pointer.
        /// </summary>
        internal static CefXmlReader From(cef_xml_reader_t* ptr)
        {
            return new CefXmlReader(ptr);
        }

        internal static CefXmlReader FromOrDefault(cef_xml_reader_t* ptr)
        {
            if (ptr == null) return null;
            return new CefXmlReader(ptr);
        }

        private cef_xml_reader_t* ptr;

        private CefXmlReader(cef_xml_reader_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefXmlReader, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefXmlReader()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefXmlReader, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_xml_reader_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_xml_reader_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_xml_reader_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_xml_reader_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_xml_reader_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefZipReader : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefZipReader proxy from pointer.
        /// </summary>
        internal static CefZipReader From(cef_zip_reader_t* ptr)
        {
            return new CefZipReader(ptr);
        }

        internal static CefZipReader FromOrDefault(cef_zip_reader_t* ptr)
        {
            if (ptr == null) return null;
            return new CefZipReader(ptr);
        }

        private cef_zip_reader_t* ptr;

        private CefZipReader(cef_zip_reader_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefZipReader, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefZipReader()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefZipReader, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_zip_reader_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_zip_reader_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_zip_reader_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_zip_reader_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_zip_reader_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefDomDocument : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefDomDocument proxy from pointer.
        /// </summary>
        internal static CefDomDocument From(cef_domdocument_t* ptr)
        {
            return new CefDomDocument(ptr);
        }

        internal static CefDomDocument FromOrDefault(cef_domdocument_t* ptr)
        {
            if (ptr == null) return null;
            return new CefDomDocument(ptr);
        }

        private cef_domdocument_t* ptr;

        private CefDomDocument(cef_domdocument_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefDomDocument, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefDomDocument()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefDomDocument, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_domdocument_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_domdocument_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_domdocument_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_domdocument_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_domdocument_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefDomNode : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefDomNode proxy from pointer.
        /// </summary>
        internal static CefDomNode From(cef_domnode_t* ptr)
        {
            return new CefDomNode(ptr);
        }

        internal static CefDomNode FromOrDefault(cef_domnode_t* ptr)
        {
            if (ptr == null) return null;
            return new CefDomNode(ptr);
        }

        private cef_domnode_t* ptr;

        private CefDomNode(cef_domnode_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefDomNode, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefDomNode()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefDomNode, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_domnode_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_domnode_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_domnode_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_domnode_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_domnode_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefDomEvent : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefDomEvent proxy from pointer.
        /// </summary>
        internal static CefDomEvent From(cef_domevent_t* ptr)
        {
            return new CefDomEvent(ptr);
        }

        internal static CefDomEvent FromOrDefault(cef_domevent_t* ptr)
        {
            if (ptr == null) return null;
            return new CefDomEvent(ptr);
        }

        private cef_domevent_t* ptr;

        private CefDomEvent(cef_domevent_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefDomEvent, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefDomEvent()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefDomEvent, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_domevent_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_domevent_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_domevent_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_domevent_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_domevent_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }

    public sealed unsafe partial class CefDragData : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        /// <summary>
        /// Create CefDragData proxy from pointer.
        /// </summary>
        internal static CefDragData From(cef_drag_data_t* ptr)
        {
            return new CefDragData(ptr);
        }

        internal static CefDragData FromOrDefault(cef_drag_data_t* ptr)
        {
            if (ptr == null) return null;
            return new CefDragData(ptr);
        }

        private cef_drag_data_t* ptr;

        private CefDragData(cef_drag_data_t* ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");

            this.ptr = ptr;

#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
            Cef.Logger.Trace(LogTarget.CefDragData, this.ptr, LogOperation.Create);
#endif

            // if (addRef) this.AddRef();
        }

        #region IDisposable
        ~CefDragData()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (this.ptr != null)
            {
                var refct = ReleaseRef();
#if DIAGNOSTICS
                var total = Interlocked.Decrement(ref ObjectCt);
                Cef.Logger.Trace(LogTarget.CefDragData, this.ptr, LogOperation.Dispose, "RefCount=[{0}]", refct);
#endif
                this.ptr = null;
            }
        }
        #endregion


        /// <summary>
        /// The AddRef method increments the reference count for the object. It should
        /// be called for every new copy of a pointer to a given object. The resulting
        /// reference count value is returned and should be used for diagnostic/testing
        /// purposes only.
        /// </summary>
        internal int AddRef()
        {
            return cef_drag_data_t.invoke_add_ref((cef_base_t*)this.ptr);
            // return add_ref(&this.ptr->@base);
        }

        /// <summary>
        /// The Release method decrements the reference count for the object. If the
        /// reference count on the object falls to 0, then the object should free
        /// itself from memory.  The resulting reference count value is returned and
        /// should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef()
        {
            return cef_drag_data_t.invoke_release((cef_base_t*)this.ptr);
            // return release(&this.ptr->@base);
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get
            {
                return cef_drag_data_t.invoke_get_refct((cef_base_t*)this.ptr);
                // return get_refct(&this.ptr->@base);
            }
        }

        internal cef_drag_data_t* NativePointer
        {
            get
            {
                return this.ptr;
            }
        }

        internal cef_drag_data_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

    }
}

