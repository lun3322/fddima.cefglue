//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using Core;
    using Diagnostics;

    public abstract unsafe partial class CefTask 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefTask> pointers = new ObjectTable<CefTask>();



        private int refct;
        private cef_task_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_task_t.execute_delegate bs_execute;

        public CefTask()
        {
            this.refct = 0;
            this.ptr = cef_task_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_execute = new cef_task_t.execute_delegate(this.execute);
            this.ptr->execute = Marshal.GetFunctionPointerForDelegate(this.bs_execute);

        }

        ~CefTask()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, "~CefTask");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_task_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_task_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_task_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefTask");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefCookieVisitor 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefCookieVisitor> pointers = new ObjectTable<CefCookieVisitor>();



        private int refct;
        private cef_cookie_visitor_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_cookie_visitor_t.visit_delegate bs_visit;

        public CefCookieVisitor()
        {
            this.refct = 0;
            this.ptr = cef_cookie_visitor_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_visit = new cef_cookie_visitor_t.visit_delegate(this.visit);
            this.ptr->visit = Marshal.GetFunctionPointerForDelegate(this.bs_visit);

        }

        ~CefCookieVisitor()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, "~CefCookieVisitor");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_cookie_visitor_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_cookie_visitor_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_cookie_visitor_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefCookieVisitor");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefLifeSpanHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefLifeSpanHandler> pointers = new ObjectTable<CefLifeSpanHandler>();



        private int refct;
        private cef_life_span_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_life_span_handler_t.on_before_popup_delegate bs_on_before_popup;
        private cef_life_span_handler_t.on_after_created_delegate bs_on_after_created;
        private cef_life_span_handler_t.run_modal_delegate bs_run_modal;
        private cef_life_span_handler_t.do_close_delegate bs_do_close;
        private cef_life_span_handler_t.on_before_close_delegate bs_on_before_close;

        public CefLifeSpanHandler()
        {
            this.refct = 0;
            this.ptr = cef_life_span_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_before_popup = new cef_life_span_handler_t.on_before_popup_delegate(this.on_before_popup);
            this.ptr->on_before_popup = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_popup);

            this.bs_on_after_created = new cef_life_span_handler_t.on_after_created_delegate(this.on_after_created);
            this.ptr->on_after_created = Marshal.GetFunctionPointerForDelegate(this.bs_on_after_created);

            this.bs_run_modal = new cef_life_span_handler_t.run_modal_delegate(this.run_modal);
            this.ptr->run_modal = Marshal.GetFunctionPointerForDelegate(this.bs_run_modal);

            this.bs_do_close = new cef_life_span_handler_t.do_close_delegate(this.do_close);
            this.ptr->do_close = Marshal.GetFunctionPointerForDelegate(this.bs_do_close);

            this.bs_on_before_close = new cef_life_span_handler_t.on_before_close_delegate(this.on_before_close);
            this.ptr->on_before_close = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_close);

        }

        ~CefLifeSpanHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, "~CefLifeSpanHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_life_span_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_life_span_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_life_span_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefLifeSpanHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefLoadHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefLoadHandler> pointers = new ObjectTable<CefLoadHandler>();



        private int refct;
        private cef_load_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_load_handler_t.on_load_start_delegate bs_on_load_start;
        private cef_load_handler_t.on_load_end_delegate bs_on_load_end;
        private cef_load_handler_t.on_load_error_delegate bs_on_load_error;

        public CefLoadHandler()
        {
            this.refct = 0;
            this.ptr = cef_load_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_load_start = new cef_load_handler_t.on_load_start_delegate(this.on_load_start);
            this.ptr->on_load_start = Marshal.GetFunctionPointerForDelegate(this.bs_on_load_start);

            this.bs_on_load_end = new cef_load_handler_t.on_load_end_delegate(this.on_load_end);
            this.ptr->on_load_end = Marshal.GetFunctionPointerForDelegate(this.bs_on_load_end);

            this.bs_on_load_error = new cef_load_handler_t.on_load_error_delegate(this.on_load_error);
            this.ptr->on_load_error = Marshal.GetFunctionPointerForDelegate(this.bs_on_load_error);

        }

        ~CefLoadHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, "~CefLoadHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_load_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_load_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_load_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefLoadHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefRequestHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefRequestHandler> pointers = new ObjectTable<CefRequestHandler>();



        private int refct;
        private cef_request_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_request_handler_t.on_before_browse_delegate bs_on_before_browse;
        private cef_request_handler_t.on_before_resource_load_delegate bs_on_before_resource_load;
        private cef_request_handler_t.on_resource_response_delegate bs_on_resource_response;
        private cef_request_handler_t.on_protocol_execution_delegate bs_on_protocol_execution;
        private cef_request_handler_t.get_download_handler_delegate bs_get_download_handler;
        private cef_request_handler_t.get_auth_credentials_delegate bs_get_auth_credentials;

        public CefRequestHandler()
        {
            this.refct = 0;
            this.ptr = cef_request_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_before_browse = new cef_request_handler_t.on_before_browse_delegate(this.on_before_browse);
            this.ptr->on_before_browse = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_browse);

            this.bs_on_before_resource_load = new cef_request_handler_t.on_before_resource_load_delegate(this.on_before_resource_load);
            this.ptr->on_before_resource_load = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_resource_load);

            this.bs_on_resource_response = new cef_request_handler_t.on_resource_response_delegate(this.on_resource_response);
            this.ptr->on_resource_response = Marshal.GetFunctionPointerForDelegate(this.bs_on_resource_response);

            this.bs_on_protocol_execution = new cef_request_handler_t.on_protocol_execution_delegate(this.on_protocol_execution);
            this.ptr->on_protocol_execution = Marshal.GetFunctionPointerForDelegate(this.bs_on_protocol_execution);

            this.bs_get_download_handler = new cef_request_handler_t.get_download_handler_delegate(this.get_download_handler);
            this.ptr->get_download_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_download_handler);

            this.bs_get_auth_credentials = new cef_request_handler_t.get_auth_credentials_delegate(this.get_auth_credentials);
            this.ptr->get_auth_credentials = Marshal.GetFunctionPointerForDelegate(this.bs_get_auth_credentials);

        }

        ~CefRequestHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, "~CefRequestHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_request_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_request_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_request_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefRequestHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefDisplayHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDisplayHandler> pointers = new ObjectTable<CefDisplayHandler>();



        private int refct;
        private cef_display_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_display_handler_t.on_nav_state_change_delegate bs_on_nav_state_change;
        private cef_display_handler_t.on_address_change_delegate bs_on_address_change;
        private cef_display_handler_t.on_title_change_delegate bs_on_title_change;
        private cef_display_handler_t.on_tooltip_delegate bs_on_tooltip;
        private cef_display_handler_t.on_status_message_delegate bs_on_status_message;
        private cef_display_handler_t.on_console_message_delegate bs_on_console_message;

        public CefDisplayHandler()
        {
            this.refct = 0;
            this.ptr = cef_display_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_nav_state_change = new cef_display_handler_t.on_nav_state_change_delegate(this.on_nav_state_change);
            this.ptr->on_nav_state_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_nav_state_change);

            this.bs_on_address_change = new cef_display_handler_t.on_address_change_delegate(this.on_address_change);
            this.ptr->on_address_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_address_change);

            this.bs_on_title_change = new cef_display_handler_t.on_title_change_delegate(this.on_title_change);
            this.ptr->on_title_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_title_change);

            this.bs_on_tooltip = new cef_display_handler_t.on_tooltip_delegate(this.on_tooltip);
            this.ptr->on_tooltip = Marshal.GetFunctionPointerForDelegate(this.bs_on_tooltip);

            this.bs_on_status_message = new cef_display_handler_t.on_status_message_delegate(this.on_status_message);
            this.ptr->on_status_message = Marshal.GetFunctionPointerForDelegate(this.bs_on_status_message);

            this.bs_on_console_message = new cef_display_handler_t.on_console_message_delegate(this.on_console_message);
            this.ptr->on_console_message = Marshal.GetFunctionPointerForDelegate(this.bs_on_console_message);

        }

        ~CefDisplayHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, "~CefDisplayHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_display_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_display_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_display_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDisplayHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefFocusHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefFocusHandler> pointers = new ObjectTable<CefFocusHandler>();



        private int refct;
        private cef_focus_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_focus_handler_t.on_take_focus_delegate bs_on_take_focus;
        private cef_focus_handler_t.on_set_focus_delegate bs_on_set_focus;

        public CefFocusHandler()
        {
            this.refct = 0;
            this.ptr = cef_focus_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_take_focus = new cef_focus_handler_t.on_take_focus_delegate(this.on_take_focus);
            this.ptr->on_take_focus = Marshal.GetFunctionPointerForDelegate(this.bs_on_take_focus);

            this.bs_on_set_focus = new cef_focus_handler_t.on_set_focus_delegate(this.on_set_focus);
            this.ptr->on_set_focus = Marshal.GetFunctionPointerForDelegate(this.bs_on_set_focus);

        }

        ~CefFocusHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, "~CefFocusHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_focus_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_focus_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_focus_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefFocusHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefKeyboardHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefKeyboardHandler> pointers = new ObjectTable<CefKeyboardHandler>();



        private int refct;
        private cef_keyboard_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_keyboard_handler_t.on_key_event_delegate bs_on_key_event;

        public CefKeyboardHandler()
        {
            this.refct = 0;
            this.ptr = cef_keyboard_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_key_event = new cef_keyboard_handler_t.on_key_event_delegate(this.on_key_event);
            this.ptr->on_key_event = Marshal.GetFunctionPointerForDelegate(this.bs_on_key_event);

        }

        ~CefKeyboardHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, "~CefKeyboardHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_keyboard_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_keyboard_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_keyboard_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefKeyboardHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefMenuHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefMenuHandler> pointers = new ObjectTable<CefMenuHandler>();



        private int refct;
        private cef_menu_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_menu_handler_t.on_before_menu_delegate bs_on_before_menu;
        private cef_menu_handler_t.get_menu_label_delegate bs_get_menu_label;
        private cef_menu_handler_t.on_menu_action_delegate bs_on_menu_action;

        public CefMenuHandler()
        {
            this.refct = 0;
            this.ptr = cef_menu_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_before_menu = new cef_menu_handler_t.on_before_menu_delegate(this.on_before_menu);
            this.ptr->on_before_menu = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_menu);

            this.bs_get_menu_label = new cef_menu_handler_t.get_menu_label_delegate(this.get_menu_label);
            this.ptr->get_menu_label = Marshal.GetFunctionPointerForDelegate(this.bs_get_menu_label);

            this.bs_on_menu_action = new cef_menu_handler_t.on_menu_action_delegate(this.on_menu_action);
            this.ptr->on_menu_action = Marshal.GetFunctionPointerForDelegate(this.bs_on_menu_action);

        }

        ~CefMenuHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, "~CefMenuHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_menu_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_menu_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_menu_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefMenuHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefPrintHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefPrintHandler> pointers = new ObjectTable<CefPrintHandler>();



        private int refct;
        private cef_print_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_print_handler_t.get_print_options_delegate bs_get_print_options;
        private cef_print_handler_t.get_print_header_footer_delegate bs_get_print_header_footer;

        public CefPrintHandler()
        {
            this.refct = 0;
            this.ptr = cef_print_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get_print_options = new cef_print_handler_t.get_print_options_delegate(this.get_print_options);
            this.ptr->get_print_options = Marshal.GetFunctionPointerForDelegate(this.bs_get_print_options);

            this.bs_get_print_header_footer = new cef_print_handler_t.get_print_header_footer_delegate(this.get_print_header_footer);
            this.ptr->get_print_header_footer = Marshal.GetFunctionPointerForDelegate(this.bs_get_print_header_footer);

        }

        ~CefPrintHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, "~CefPrintHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_print_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_print_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_print_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefPrintHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefFindHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefFindHandler> pointers = new ObjectTable<CefFindHandler>();



        private int refct;
        private cef_find_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_find_handler_t.on_find_result_delegate bs_on_find_result;

        public CefFindHandler()
        {
            this.refct = 0;
            this.ptr = cef_find_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_find_result = new cef_find_handler_t.on_find_result_delegate(this.on_find_result);
            this.ptr->on_find_result = Marshal.GetFunctionPointerForDelegate(this.bs_on_find_result);

        }

        ~CefFindHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, "~CefFindHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_find_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_find_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_find_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefFindHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefJSDialogHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefJSDialogHandler> pointers = new ObjectTable<CefJSDialogHandler>();



        private int refct;
        private cef_jsdialog_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_jsdialog_handler_t.on_jsalert_delegate bs_on_jsalert;
        private cef_jsdialog_handler_t.on_jsconfirm_delegate bs_on_jsconfirm;
        private cef_jsdialog_handler_t.on_jsprompt_delegate bs_on_jsprompt;

        public CefJSDialogHandler()
        {
            this.refct = 0;
            this.ptr = cef_jsdialog_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_jsalert = new cef_jsdialog_handler_t.on_jsalert_delegate(this.on_jsalert);
            this.ptr->on_jsalert = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsalert);

            this.bs_on_jsconfirm = new cef_jsdialog_handler_t.on_jsconfirm_delegate(this.on_jsconfirm);
            this.ptr->on_jsconfirm = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsconfirm);

            this.bs_on_jsprompt = new cef_jsdialog_handler_t.on_jsprompt_delegate(this.on_jsprompt);
            this.ptr->on_jsprompt = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsprompt);

        }

        ~CefJSDialogHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, "~CefJSDialogHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_jsdialog_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_jsdialog_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_jsdialog_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefJSDialogHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefJSBindingHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefJSBindingHandler> pointers = new ObjectTable<CefJSBindingHandler>();



        private int refct;
        private cef_jsbinding_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_jsbinding_handler_t.on_jsbinding_delegate bs_on_jsbinding;

        public CefJSBindingHandler()
        {
            this.refct = 0;
            this.ptr = cef_jsbinding_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_jsbinding = new cef_jsbinding_handler_t.on_jsbinding_delegate(this.on_jsbinding);
            this.ptr->on_jsbinding = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsbinding);

        }

        ~CefJSBindingHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, "~CefJSBindingHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_jsbinding_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_jsbinding_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_jsbinding_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefJSBindingHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefRenderHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefRenderHandler> pointers = new ObjectTable<CefRenderHandler>();



        private int refct;
        private cef_render_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_render_handler_t.get_view_rect_delegate bs_get_view_rect;
        private cef_render_handler_t.get_screen_rect_delegate bs_get_screen_rect;
        private cef_render_handler_t.get_screen_point_delegate bs_get_screen_point;
        private cef_render_handler_t.on_popup_show_delegate bs_on_popup_show;
        private cef_render_handler_t.on_popup_size_delegate bs_on_popup_size;
        private cef_render_handler_t.on_paint_delegate bs_on_paint;
        private cef_render_handler_t.on_cursor_change_delegate bs_on_cursor_change;

        public CefRenderHandler()
        {
            this.refct = 0;
            this.ptr = cef_render_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get_view_rect = new cef_render_handler_t.get_view_rect_delegate(this.get_view_rect);
            this.ptr->get_view_rect = Marshal.GetFunctionPointerForDelegate(this.bs_get_view_rect);

            this.bs_get_screen_rect = new cef_render_handler_t.get_screen_rect_delegate(this.get_screen_rect);
            this.ptr->get_screen_rect = Marshal.GetFunctionPointerForDelegate(this.bs_get_screen_rect);

            this.bs_get_screen_point = new cef_render_handler_t.get_screen_point_delegate(this.get_screen_point);
            this.ptr->get_screen_point = Marshal.GetFunctionPointerForDelegate(this.bs_get_screen_point);

            this.bs_on_popup_show = new cef_render_handler_t.on_popup_show_delegate(this.on_popup_show);
            this.ptr->on_popup_show = Marshal.GetFunctionPointerForDelegate(this.bs_on_popup_show);

            this.bs_on_popup_size = new cef_render_handler_t.on_popup_size_delegate(this.on_popup_size);
            this.ptr->on_popup_size = Marshal.GetFunctionPointerForDelegate(this.bs_on_popup_size);

            this.bs_on_paint = new cef_render_handler_t.on_paint_delegate(this.on_paint);
            this.ptr->on_paint = Marshal.GetFunctionPointerForDelegate(this.bs_on_paint);

            this.bs_on_cursor_change = new cef_render_handler_t.on_cursor_change_delegate(this.on_cursor_change);
            this.ptr->on_cursor_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_cursor_change);

        }

        ~CefRenderHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, "~CefRenderHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_render_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_render_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_render_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefRenderHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefClient : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefClient> pointers = new ObjectTable<CefClient>();

        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static CefClient From(cef_client_t* pointer)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, pointer, "From");
#endif
            if (pointer == null) ThrowNullNativePointer();
            CefClient value;
            if (!pointers.TryGetValue((IntPtr)pointer, out value)) ThrowObjectNotFound();
			value.ReleaseRef();
            return value;
        }
		
		internal static CefClient FromOrDefault(cef_client_t* pointer)
		{
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, pointer, "FromOrDefault");
#endif
            if (pointer == null) return null;
            CefClient value;
            if (!pointers.TryGetValue((IntPtr)pointer, out value)) ThrowObjectNotFound();
			value.ReleaseRef();
            return value;
		}
		
		private static void ThrowObjectNotFound()
		{
		    throw new CefGlueException("CefClient not found.");
		}
		
        private static void ThrowNullNativePointer()
        {
            throw new NullReferenceException("CefClient");
        }


        private int refct;
        private cef_client_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_client_t.get_life_span_handler_delegate bs_get_life_span_handler;
        private cef_client_t.get_load_handler_delegate bs_get_load_handler;
        private cef_client_t.get_request_handler_delegate bs_get_request_handler;
        private cef_client_t.get_display_handler_delegate bs_get_display_handler;
        private cef_client_t.get_focus_handler_delegate bs_get_focus_handler;
        private cef_client_t.get_keyboard_handler_delegate bs_get_keyboard_handler;
        private cef_client_t.get_menu_handler_delegate bs_get_menu_handler;
        private cef_client_t.get_print_handler_delegate bs_get_print_handler;
        private cef_client_t.get_find_handler_delegate bs_get_find_handler;
        private cef_client_t.get_jsdialog_handler_delegate bs_get_jsdialog_handler;
        private cef_client_t.get_jsbinding_handler_delegate bs_get_jsbinding_handler;
        private cef_client_t.get_render_handler_delegate bs_get_render_handler;

        public CefClient()
        {
            this.refct = 0;
            this.ptr = cef_client_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get_life_span_handler = new cef_client_t.get_life_span_handler_delegate(this.get_life_span_handler);
            this.ptr->get_life_span_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_life_span_handler);

            this.bs_get_load_handler = new cef_client_t.get_load_handler_delegate(this.get_load_handler);
            this.ptr->get_load_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_load_handler);

            this.bs_get_request_handler = new cef_client_t.get_request_handler_delegate(this.get_request_handler);
            this.ptr->get_request_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_request_handler);

            this.bs_get_display_handler = new cef_client_t.get_display_handler_delegate(this.get_display_handler);
            this.ptr->get_display_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_display_handler);

            this.bs_get_focus_handler = new cef_client_t.get_focus_handler_delegate(this.get_focus_handler);
            this.ptr->get_focus_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_focus_handler);

            this.bs_get_keyboard_handler = new cef_client_t.get_keyboard_handler_delegate(this.get_keyboard_handler);
            this.ptr->get_keyboard_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_keyboard_handler);

            this.bs_get_menu_handler = new cef_client_t.get_menu_handler_delegate(this.get_menu_handler);
            this.ptr->get_menu_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_menu_handler);

            this.bs_get_print_handler = new cef_client_t.get_print_handler_delegate(this.get_print_handler);
            this.ptr->get_print_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_print_handler);

            this.bs_get_find_handler = new cef_client_t.get_find_handler_delegate(this.get_find_handler);
            this.ptr->get_find_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_find_handler);

            this.bs_get_jsdialog_handler = new cef_client_t.get_jsdialog_handler_delegate(this.get_jsdialog_handler);
            this.ptr->get_jsdialog_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_jsdialog_handler);

            this.bs_get_jsbinding_handler = new cef_client_t.get_jsbinding_handler_delegate(this.get_jsbinding_handler);
            this.ptr->get_jsbinding_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_jsbinding_handler);

            this.bs_get_render_handler = new cef_client_t.get_render_handler_delegate(this.get_render_handler);
            this.ptr->get_render_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_render_handler);

        }

        ~CefClient()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, "~CefClient");
#endif
			Dispose(false);
        }

        public void Dispose()
        {
		    if (this.RefCount == 0)
			{
			    Dispose(true);
				GC.SuppressFinalize(this);
			}
			else
			{
                this.disposed = true;
            }
        }

		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_client_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_client_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_client_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefClient");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefReadHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefReadHandler> pointers = new ObjectTable<CefReadHandler>();



        private int refct;
        private cef_read_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_read_handler_t.read_delegate bs_read;
        private cef_read_handler_t.seek_delegate bs_seek;
        private cef_read_handler_t.tell_delegate bs_tell;
        private cef_read_handler_t.eof_delegate bs_eof;

        public CefReadHandler()
        {
            this.refct = 0;
            this.ptr = cef_read_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_read = new cef_read_handler_t.read_delegate(this.read);
            this.ptr->read = Marshal.GetFunctionPointerForDelegate(this.bs_read);

            this.bs_seek = new cef_read_handler_t.seek_delegate(this.seek);
            this.ptr->seek = Marshal.GetFunctionPointerForDelegate(this.bs_seek);

            this.bs_tell = new cef_read_handler_t.tell_delegate(this.tell);
            this.ptr->tell = Marshal.GetFunctionPointerForDelegate(this.bs_tell);

            this.bs_eof = new cef_read_handler_t.eof_delegate(this.eof);
            this.ptr->eof = Marshal.GetFunctionPointerForDelegate(this.bs_eof);

        }

        ~CefReadHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, "~CefReadHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_read_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_read_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_read_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefReadHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefWriteHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefWriteHandler> pointers = new ObjectTable<CefWriteHandler>();



        private int refct;
        private cef_write_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_write_handler_t.write_delegate bs_write;
        private cef_write_handler_t.seek_delegate bs_seek;
        private cef_write_handler_t.tell_delegate bs_tell;
        private cef_write_handler_t.flush_delegate bs_flush;

        public CefWriteHandler()
        {
            this.refct = 0;
            this.ptr = cef_write_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_write = new cef_write_handler_t.write_delegate(this.write);
            this.ptr->write = Marshal.GetFunctionPointerForDelegate(this.bs_write);

            this.bs_seek = new cef_write_handler_t.seek_delegate(this.seek);
            this.ptr->seek = Marshal.GetFunctionPointerForDelegate(this.bs_seek);

            this.bs_tell = new cef_write_handler_t.tell_delegate(this.tell);
            this.ptr->tell = Marshal.GetFunctionPointerForDelegate(this.bs_tell);

            this.bs_flush = new cef_write_handler_t.flush_delegate(this.flush);
            this.ptr->flush = Marshal.GetFunctionPointerForDelegate(this.bs_flush);

        }

        ~CefWriteHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, "~CefWriteHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_write_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_write_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_write_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefWriteHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefV8Handler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefV8Handler> pointers = new ObjectTable<CefV8Handler>();

        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static CefV8Handler From(cef_v8handler_t* pointer)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, pointer, "From");
#endif
            if (pointer == null) ThrowNullNativePointer();
            CefV8Handler value;
            if (!pointers.TryGetValue((IntPtr)pointer, out value)) ThrowObjectNotFound();
			value.ReleaseRef();
            return value;
        }
		
		internal static CefV8Handler FromOrDefault(cef_v8handler_t* pointer)
		{
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, pointer, "FromOrDefault");
#endif
            if (pointer == null) return null;
            CefV8Handler value;
            if (!pointers.TryGetValue((IntPtr)pointer, out value)) ThrowObjectNotFound();
			value.ReleaseRef();
            return value;
		}
		
		private static void ThrowObjectNotFound()
		{
		    throw new CefGlueException("CefV8Handler not found.");
		}
		
        private static void ThrowNullNativePointer()
        {
            throw new NullReferenceException("CefV8Handler");
        }


        private int refct;
        private cef_v8handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_v8handler_t.execute_delegate bs_execute;

        public CefV8Handler()
        {
            this.refct = 0;
            this.ptr = cef_v8handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_execute = new cef_v8handler_t.execute_delegate(this.execute);
            this.ptr->execute = Marshal.GetFunctionPointerForDelegate(this.bs_execute);

        }

        ~CefV8Handler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, "~CefV8Handler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_v8handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_v8handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_v8handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefV8Handler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefV8Accessor 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefV8Accessor> pointers = new ObjectTable<CefV8Accessor>();



        private int refct;
        private cef_v8accessor_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_v8accessor_t.get_delegate bs_get;
        private cef_v8accessor_t.set_delegate bs_set;

        public CefV8Accessor()
        {
            this.refct = 0;
            this.ptr = cef_v8accessor_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get = new cef_v8accessor_t.get_delegate(this.get);
            this.ptr->get = Marshal.GetFunctionPointerForDelegate(this.bs_get);

            this.bs_set = new cef_v8accessor_t.set_delegate(this.set);
            this.ptr->set = Marshal.GetFunctionPointerForDelegate(this.bs_set);

        }

        ~CefV8Accessor()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, "~CefV8Accessor");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_v8accessor_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_v8accessor_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_v8accessor_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefV8Accessor");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefSchemeHandlerFactory 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefSchemeHandlerFactory> pointers = new ObjectTable<CefSchemeHandlerFactory>();



        private int refct;
        private cef_scheme_handler_factory_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_scheme_handler_factory_t.create_delegate bs_create;

        public CefSchemeHandlerFactory()
        {
            this.refct = 0;
            this.ptr = cef_scheme_handler_factory_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_create = new cef_scheme_handler_factory_t.create_delegate(this.create);
            this.ptr->create = Marshal.GetFunctionPointerForDelegate(this.bs_create);

        }

        ~CefSchemeHandlerFactory()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, "~CefSchemeHandlerFactory");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_scheme_handler_factory_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_scheme_handler_factory_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_scheme_handler_factory_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefSchemeHandlerFactory");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefSchemeHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefSchemeHandler> pointers = new ObjectTable<CefSchemeHandler>();



        private int refct;
        private cef_scheme_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_scheme_handler_t.process_request_delegate bs_process_request;
        private cef_scheme_handler_t.cancel_delegate bs_cancel;
        private cef_scheme_handler_t.read_response_delegate bs_read_response;

        public CefSchemeHandler()
        {
            this.refct = 0;
            this.ptr = cef_scheme_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_process_request = new cef_scheme_handler_t.process_request_delegate(this.process_request);
            this.ptr->process_request = Marshal.GetFunctionPointerForDelegate(this.bs_process_request);

            this.bs_cancel = new cef_scheme_handler_t.cancel_delegate(this.cancel);
            this.ptr->cancel = Marshal.GetFunctionPointerForDelegate(this.bs_cancel);

            this.bs_read_response = new cef_scheme_handler_t.read_response_delegate(this.read_response);
            this.ptr->read_response = Marshal.GetFunctionPointerForDelegate(this.bs_read_response);

        }

        ~CefSchemeHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, "~CefSchemeHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_scheme_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_scheme_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_scheme_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefSchemeHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefDownloadHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDownloadHandler> pointers = new ObjectTable<CefDownloadHandler>();



        private int refct;
        private cef_download_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_download_handler_t.received_data_delegate bs_received_data;
        private cef_download_handler_t.complete_delegate bs_complete;

        public CefDownloadHandler()
        {
            this.refct = 0;
            this.ptr = cef_download_handler_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_received_data = new cef_download_handler_t.received_data_delegate(this.received_data);
            this.ptr->received_data = Marshal.GetFunctionPointerForDelegate(this.bs_received_data);

            this.bs_complete = new cef_download_handler_t.complete_delegate(this.complete);
            this.ptr->complete = Marshal.GetFunctionPointerForDelegate(this.bs_complete);

        }

        ~CefDownloadHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, "~CefDownloadHandler");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_download_handler_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_download_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_download_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDownloadHandler");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefWebUrlRequestClient 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefWebUrlRequestClient> pointers = new ObjectTable<CefWebUrlRequestClient>();



        private int refct;
        private cef_web_urlrequest_client_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_web_urlrequest_client_t.on_state_change_delegate bs_on_state_change;
        private cef_web_urlrequest_client_t.on_redirect_delegate bs_on_redirect;
        private cef_web_urlrequest_client_t.on_headers_received_delegate bs_on_headers_received;
        private cef_web_urlrequest_client_t.on_progress_delegate bs_on_progress;
        private cef_web_urlrequest_client_t.on_data_delegate bs_on_data;
        private cef_web_urlrequest_client_t.on_error_delegate bs_on_error;

        public CefWebUrlRequestClient()
        {
            this.refct = 0;
            this.ptr = cef_web_urlrequest_client_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_state_change = new cef_web_urlrequest_client_t.on_state_change_delegate(this.on_state_change);
            this.ptr->on_state_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_state_change);

            this.bs_on_redirect = new cef_web_urlrequest_client_t.on_redirect_delegate(this.on_redirect);
            this.ptr->on_redirect = Marshal.GetFunctionPointerForDelegate(this.bs_on_redirect);

            this.bs_on_headers_received = new cef_web_urlrequest_client_t.on_headers_received_delegate(this.on_headers_received);
            this.ptr->on_headers_received = Marshal.GetFunctionPointerForDelegate(this.bs_on_headers_received);

            this.bs_on_progress = new cef_web_urlrequest_client_t.on_progress_delegate(this.on_progress);
            this.ptr->on_progress = Marshal.GetFunctionPointerForDelegate(this.bs_on_progress);

            this.bs_on_data = new cef_web_urlrequest_client_t.on_data_delegate(this.on_data);
            this.ptr->on_data = Marshal.GetFunctionPointerForDelegate(this.bs_on_data);

            this.bs_on_error = new cef_web_urlrequest_client_t.on_error_delegate(this.on_error);
            this.ptr->on_error = Marshal.GetFunctionPointerForDelegate(this.bs_on_error);

        }

        ~CefWebUrlRequestClient()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, "~CefWebUrlRequestClient");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_web_urlrequest_client_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_web_urlrequest_client_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_web_urlrequest_client_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefWebUrlRequestClient");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefDomVisitor 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDomVisitor> pointers = new ObjectTable<CefDomVisitor>();



        private int refct;
        private cef_domvisitor_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_domvisitor_t.visit_delegate bs_visit;

        public CefDomVisitor()
        {
            this.refct = 0;
            this.ptr = cef_domvisitor_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_visit = new cef_domvisitor_t.visit_delegate(this.visit);
            this.ptr->visit = Marshal.GetFunctionPointerForDelegate(this.bs_visit);

        }

        ~CefDomVisitor()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, "~CefDomVisitor");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_domvisitor_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_domvisitor_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_domvisitor_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDomVisitor");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefDomEventListener 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDomEventListener> pointers = new ObjectTable<CefDomEventListener>();



        private int refct;
        private cef_domevent_listener_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_domevent_listener_t.handle_event_delegate bs_handle_event;

        public CefDomEventListener()
        {
            this.refct = 0;
            this.ptr = cef_domevent_listener_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_handle_event = new cef_domevent_listener_t.handle_event_delegate(this.handle_event);
            this.ptr->handle_event = Marshal.GetFunctionPointerForDelegate(this.bs_handle_event);

        }

        ~CefDomEventListener()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, "~CefDomEventListener");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_domevent_listener_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_domevent_listener_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_domevent_listener_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDomEventListener");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefContentFilter 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefContentFilter> pointers = new ObjectTable<CefContentFilter>();



        private int refct;
        private cef_content_filter_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_content_filter_t.process_data_delegate bs_process_data;
        private cef_content_filter_t.drain_delegate bs_drain;

        public CefContentFilter()
        {
            this.refct = 0;
            this.ptr = cef_content_filter_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_process_data = new cef_content_filter_t.process_data_delegate(this.process_data);
            this.ptr->process_data = Marshal.GetFunctionPointerForDelegate(this.bs_process_data);

            this.bs_drain = new cef_content_filter_t.drain_delegate(this.drain);
            this.ptr->drain = Marshal.GetFunctionPointerForDelegate(this.bs_drain);

        }

        ~CefContentFilter()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, "~CefContentFilter");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cef_content_filter_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_content_filter_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_content_filter_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefContentFilter");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }

    public abstract unsafe partial class CefUserData 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefUserData> pointers = new ObjectTable<CefUserData>();

        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static CefUserData From(cefglue_userdata_t* pointer)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, pointer, "From");
#endif
            if (pointer == null) ThrowNullNativePointer();
            CefUserData value;
            if (!pointers.TryGetValue((IntPtr)pointer, out value)) ThrowObjectNotFound();
			value.ReleaseRef();
            return value;
        }
		
		internal static CefUserData FromOrDefault(cefglue_userdata_t* pointer)
		{
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, pointer, "FromOrDefault");
#endif
            if (pointer == null) return null;
            CefUserData value;
            if (!pointers.TryGetValue((IntPtr)pointer, out value)) ThrowObjectNotFound();
			value.ReleaseRef();
            return value;
		}
		
		private static void ThrowObjectNotFound()
		{
		    throw new CefGlueException("CefUserData not found.");
		}
		
        private static void ThrowNullNativePointer()
        {
            throw new NullReferenceException("CefUserData");
        }


        private int refct;
        private cefglue_userdata_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;

        public CefUserData()
        {
            this.refct = 0;
            this.ptr = cefglue_userdata_t.Alloc();
#if DIAGNOSTICS
			Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

        }

        ~CefUserData()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, "~CefUserData");
#endif
			Dispose(false);
        }


		protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

			this.disposed = true;

			if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
				cefglue_userdata_t.Free(this.ptr);
                this.ptr = null;
			}

            if (disposing)
			{
			}
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
		/// It should be called for every new copy of a pointer to a given object.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
			if (result == 1)
			{
				pointers.Add((IntPtr)ptr, this);
			}
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
		/// If the reference count on the object falls to 0, then the object should free itself from memory.
		/// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
			if (result == 0)
			{
                pointers.Remove((IntPtr)ptr);
			}
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cefglue_userdata_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cefglue_userdata_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefUserData");
        }

		[Conditional("DEBUG")]
		private void CheckNativePointer()
		{
            if (this.ptr == null) ThrowObjectDisposedException();
		}
    }
}

