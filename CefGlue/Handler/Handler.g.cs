//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using Core;
    using Diagnostics;

    public abstract unsafe partial class CefTask 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefTask> pointers = new ObjectTable<CefTask>();



        private int refct;
        private cef_task_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_task_t.execute_delegate bs_execute;

        protected CefTask()
        {
            this.refct = 0;
            this.ptr = cef_task_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_execute = new cef_task_t.execute_delegate(this.execute);
            this.ptr->execute = Marshal.GetFunctionPointerForDelegate(this.bs_execute);

        }

        ~CefTask()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, "~CefTask");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_task_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefTask, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_task_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_task_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefTask");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefCookieVisitor 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefCookieVisitor> pointers = new ObjectTable<CefCookieVisitor>();



        private int refct;
        private cef_cookie_visitor_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_cookie_visitor_t.visit_delegate bs_visit;

        protected CefCookieVisitor()
        {
            this.refct = 0;
            this.ptr = cef_cookie_visitor_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_visit = new cef_cookie_visitor_t.visit_delegate(this.visit);
            this.ptr->visit = Marshal.GetFunctionPointerForDelegate(this.bs_visit);

        }

        ~CefCookieVisitor()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, "~CefCookieVisitor");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_cookie_visitor_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefCookieVisitor, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_cookie_visitor_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_cookie_visitor_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefCookieVisitor");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefLifeSpanHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefLifeSpanHandler> pointers = new ObjectTable<CefLifeSpanHandler>();



        private int refct;
        private cef_life_span_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_life_span_handler_t.on_before_popup_delegate bs_on_before_popup;
        private cef_life_span_handler_t.on_after_created_delegate bs_on_after_created;
        private cef_life_span_handler_t.run_modal_delegate bs_run_modal;
        private cef_life_span_handler_t.do_close_delegate bs_do_close;
        private cef_life_span_handler_t.on_before_close_delegate bs_on_before_close;

        protected CefLifeSpanHandler()
        {
            this.refct = 0;
            this.ptr = cef_life_span_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_before_popup = new cef_life_span_handler_t.on_before_popup_delegate(this.on_before_popup);
            this.ptr->on_before_popup = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_popup);

            this.bs_on_after_created = new cef_life_span_handler_t.on_after_created_delegate(this.on_after_created);
            this.ptr->on_after_created = Marshal.GetFunctionPointerForDelegate(this.bs_on_after_created);

            this.bs_run_modal = new cef_life_span_handler_t.run_modal_delegate(this.run_modal);
            this.ptr->run_modal = Marshal.GetFunctionPointerForDelegate(this.bs_run_modal);

            this.bs_do_close = new cef_life_span_handler_t.do_close_delegate(this.do_close);
            this.ptr->do_close = Marshal.GetFunctionPointerForDelegate(this.bs_do_close);

            this.bs_on_before_close = new cef_life_span_handler_t.on_before_close_delegate(this.on_before_close);
            this.ptr->on_before_close = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_close);

        }

        ~CefLifeSpanHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, "~CefLifeSpanHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_life_span_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLifeSpanHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_life_span_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_life_span_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefLifeSpanHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefLoadHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefLoadHandler> pointers = new ObjectTable<CefLoadHandler>();



        private int refct;
        private cef_load_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_load_handler_t.on_load_start_delegate bs_on_load_start;
        private cef_load_handler_t.on_load_end_delegate bs_on_load_end;
        private cef_load_handler_t.on_load_error_delegate bs_on_load_error;

        protected CefLoadHandler()
        {
            this.refct = 0;
            this.ptr = cef_load_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_load_start = new cef_load_handler_t.on_load_start_delegate(this.on_load_start);
            this.ptr->on_load_start = Marshal.GetFunctionPointerForDelegate(this.bs_on_load_start);

            this.bs_on_load_end = new cef_load_handler_t.on_load_end_delegate(this.on_load_end);
            this.ptr->on_load_end = Marshal.GetFunctionPointerForDelegate(this.bs_on_load_end);

            this.bs_on_load_error = new cef_load_handler_t.on_load_error_delegate(this.on_load_error);
            this.ptr->on_load_error = Marshal.GetFunctionPointerForDelegate(this.bs_on_load_error);

        }

        ~CefLoadHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, "~CefLoadHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_load_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefLoadHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_load_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_load_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefLoadHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefRequestHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefRequestHandler> pointers = new ObjectTable<CefRequestHandler>();



        private int refct;
        private cef_request_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_request_handler_t.on_before_browse_delegate bs_on_before_browse;
        private cef_request_handler_t.on_before_resource_load_delegate bs_on_before_resource_load;
        private cef_request_handler_t.on_resource_response_delegate bs_on_resource_response;
        private cef_request_handler_t.on_protocol_execution_delegate bs_on_protocol_execution;
        private cef_request_handler_t.get_download_handler_delegate bs_get_download_handler;
        private cef_request_handler_t.get_auth_credentials_delegate bs_get_auth_credentials;

        protected CefRequestHandler()
        {
            this.refct = 0;
            this.ptr = cef_request_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_before_browse = new cef_request_handler_t.on_before_browse_delegate(this.on_before_browse);
            this.ptr->on_before_browse = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_browse);

            this.bs_on_before_resource_load = new cef_request_handler_t.on_before_resource_load_delegate(this.on_before_resource_load);
            this.ptr->on_before_resource_load = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_resource_load);

            this.bs_on_resource_response = new cef_request_handler_t.on_resource_response_delegate(this.on_resource_response);
            this.ptr->on_resource_response = Marshal.GetFunctionPointerForDelegate(this.bs_on_resource_response);

            this.bs_on_protocol_execution = new cef_request_handler_t.on_protocol_execution_delegate(this.on_protocol_execution);
            this.ptr->on_protocol_execution = Marshal.GetFunctionPointerForDelegate(this.bs_on_protocol_execution);

            this.bs_get_download_handler = new cef_request_handler_t.get_download_handler_delegate(this.get_download_handler);
            this.ptr->get_download_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_download_handler);

            this.bs_get_auth_credentials = new cef_request_handler_t.get_auth_credentials_delegate(this.get_auth_credentials);
            this.ptr->get_auth_credentials = Marshal.GetFunctionPointerForDelegate(this.bs_get_auth_credentials);

        }

        ~CefRequestHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, "~CefRequestHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_request_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRequestHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_request_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_request_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefRequestHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefDisplayHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDisplayHandler> pointers = new ObjectTable<CefDisplayHandler>();



        private int refct;
        private cef_display_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_display_handler_t.on_nav_state_change_delegate bs_on_nav_state_change;
        private cef_display_handler_t.on_address_change_delegate bs_on_address_change;
        private cef_display_handler_t.on_title_change_delegate bs_on_title_change;
        private cef_display_handler_t.on_tooltip_delegate bs_on_tooltip;
        private cef_display_handler_t.on_status_message_delegate bs_on_status_message;
        private cef_display_handler_t.on_console_message_delegate bs_on_console_message;

        protected CefDisplayHandler()
        {
            this.refct = 0;
            this.ptr = cef_display_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_nav_state_change = new cef_display_handler_t.on_nav_state_change_delegate(this.on_nav_state_change);
            this.ptr->on_nav_state_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_nav_state_change);

            this.bs_on_address_change = new cef_display_handler_t.on_address_change_delegate(this.on_address_change);
            this.ptr->on_address_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_address_change);

            this.bs_on_title_change = new cef_display_handler_t.on_title_change_delegate(this.on_title_change);
            this.ptr->on_title_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_title_change);

            this.bs_on_tooltip = new cef_display_handler_t.on_tooltip_delegate(this.on_tooltip);
            this.ptr->on_tooltip = Marshal.GetFunctionPointerForDelegate(this.bs_on_tooltip);

            this.bs_on_status_message = new cef_display_handler_t.on_status_message_delegate(this.on_status_message);
            this.ptr->on_status_message = Marshal.GetFunctionPointerForDelegate(this.bs_on_status_message);

            this.bs_on_console_message = new cef_display_handler_t.on_console_message_delegate(this.on_console_message);
            this.ptr->on_console_message = Marshal.GetFunctionPointerForDelegate(this.bs_on_console_message);

        }

        ~CefDisplayHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, "~CefDisplayHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_display_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDisplayHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_display_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_display_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDisplayHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefFocusHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefFocusHandler> pointers = new ObjectTable<CefFocusHandler>();



        private int refct;
        private cef_focus_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_focus_handler_t.on_take_focus_delegate bs_on_take_focus;
        private cef_focus_handler_t.on_set_focus_delegate bs_on_set_focus;

        protected CefFocusHandler()
        {
            this.refct = 0;
            this.ptr = cef_focus_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_take_focus = new cef_focus_handler_t.on_take_focus_delegate(this.on_take_focus);
            this.ptr->on_take_focus = Marshal.GetFunctionPointerForDelegate(this.bs_on_take_focus);

            this.bs_on_set_focus = new cef_focus_handler_t.on_set_focus_delegate(this.on_set_focus);
            this.ptr->on_set_focus = Marshal.GetFunctionPointerForDelegate(this.bs_on_set_focus);

        }

        ~CefFocusHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, "~CefFocusHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_focus_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFocusHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_focus_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_focus_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefFocusHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefKeyboardHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefKeyboardHandler> pointers = new ObjectTable<CefKeyboardHandler>();



        private int refct;
        private cef_keyboard_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_keyboard_handler_t.on_key_event_delegate bs_on_key_event;

        protected CefKeyboardHandler()
        {
            this.refct = 0;
            this.ptr = cef_keyboard_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_key_event = new cef_keyboard_handler_t.on_key_event_delegate(this.on_key_event);
            this.ptr->on_key_event = Marshal.GetFunctionPointerForDelegate(this.bs_on_key_event);

        }

        ~CefKeyboardHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, "~CefKeyboardHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_keyboard_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefKeyboardHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_keyboard_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_keyboard_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefKeyboardHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefMenuHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefMenuHandler> pointers = new ObjectTable<CefMenuHandler>();



        private int refct;
        private cef_menu_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_menu_handler_t.on_before_menu_delegate bs_on_before_menu;
        private cef_menu_handler_t.get_menu_label_delegate bs_get_menu_label;
        private cef_menu_handler_t.on_menu_action_delegate bs_on_menu_action;

        protected CefMenuHandler()
        {
            this.refct = 0;
            this.ptr = cef_menu_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_before_menu = new cef_menu_handler_t.on_before_menu_delegate(this.on_before_menu);
            this.ptr->on_before_menu = Marshal.GetFunctionPointerForDelegate(this.bs_on_before_menu);

            this.bs_get_menu_label = new cef_menu_handler_t.get_menu_label_delegate(this.get_menu_label);
            this.ptr->get_menu_label = Marshal.GetFunctionPointerForDelegate(this.bs_get_menu_label);

            this.bs_on_menu_action = new cef_menu_handler_t.on_menu_action_delegate(this.on_menu_action);
            this.ptr->on_menu_action = Marshal.GetFunctionPointerForDelegate(this.bs_on_menu_action);

        }

        ~CefMenuHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, "~CefMenuHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_menu_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefMenuHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_menu_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_menu_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefMenuHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefPrintHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefPrintHandler> pointers = new ObjectTable<CefPrintHandler>();



        private int refct;
        private cef_print_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_print_handler_t.get_print_options_delegate bs_get_print_options;
        private cef_print_handler_t.get_print_header_footer_delegate bs_get_print_header_footer;

        protected CefPrintHandler()
        {
            this.refct = 0;
            this.ptr = cef_print_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get_print_options = new cef_print_handler_t.get_print_options_delegate(this.get_print_options);
            this.ptr->get_print_options = Marshal.GetFunctionPointerForDelegate(this.bs_get_print_options);

            this.bs_get_print_header_footer = new cef_print_handler_t.get_print_header_footer_delegate(this.get_print_header_footer);
            this.ptr->get_print_header_footer = Marshal.GetFunctionPointerForDelegate(this.bs_get_print_header_footer);

        }

        ~CefPrintHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, "~CefPrintHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_print_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefPrintHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_print_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_print_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefPrintHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefFindHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefFindHandler> pointers = new ObjectTable<CefFindHandler>();



        private int refct;
        private cef_find_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_find_handler_t.on_find_result_delegate bs_on_find_result;

        protected CefFindHandler()
        {
            this.refct = 0;
            this.ptr = cef_find_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_find_result = new cef_find_handler_t.on_find_result_delegate(this.on_find_result);
            this.ptr->on_find_result = Marshal.GetFunctionPointerForDelegate(this.bs_on_find_result);

        }

        ~CefFindHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, "~CefFindHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_find_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefFindHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_find_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_find_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefFindHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefJSDialogHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefJSDialogHandler> pointers = new ObjectTable<CefJSDialogHandler>();



        private int refct;
        private cef_jsdialog_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_jsdialog_handler_t.on_jsalert_delegate bs_on_jsalert;
        private cef_jsdialog_handler_t.on_jsconfirm_delegate bs_on_jsconfirm;
        private cef_jsdialog_handler_t.on_jsprompt_delegate bs_on_jsprompt;

        protected CefJSDialogHandler()
        {
            this.refct = 0;
            this.ptr = cef_jsdialog_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_jsalert = new cef_jsdialog_handler_t.on_jsalert_delegate(this.on_jsalert);
            this.ptr->on_jsalert = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsalert);

            this.bs_on_jsconfirm = new cef_jsdialog_handler_t.on_jsconfirm_delegate(this.on_jsconfirm);
            this.ptr->on_jsconfirm = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsconfirm);

            this.bs_on_jsprompt = new cef_jsdialog_handler_t.on_jsprompt_delegate(this.on_jsprompt);
            this.ptr->on_jsprompt = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsprompt);

        }

        ~CefJSDialogHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, "~CefJSDialogHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_jsdialog_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSDialogHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_jsdialog_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_jsdialog_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefJSDialogHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefJSBindingHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefJSBindingHandler> pointers = new ObjectTable<CefJSBindingHandler>();



        private int refct;
        private cef_jsbinding_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_jsbinding_handler_t.on_jsbinding_delegate bs_on_jsbinding;

        protected CefJSBindingHandler()
        {
            this.refct = 0;
            this.ptr = cef_jsbinding_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_jsbinding = new cef_jsbinding_handler_t.on_jsbinding_delegate(this.on_jsbinding);
            this.ptr->on_jsbinding = Marshal.GetFunctionPointerForDelegate(this.bs_on_jsbinding);

        }

        ~CefJSBindingHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, "~CefJSBindingHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_jsbinding_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefJSBindingHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_jsbinding_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_jsbinding_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefJSBindingHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefRenderHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefRenderHandler> pointers = new ObjectTable<CefRenderHandler>();



        private int refct;
        private cef_render_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_render_handler_t.get_view_rect_delegate bs_get_view_rect;
        private cef_render_handler_t.get_screen_rect_delegate bs_get_screen_rect;
        private cef_render_handler_t.get_screen_point_delegate bs_get_screen_point;
        private cef_render_handler_t.on_popup_show_delegate bs_on_popup_show;
        private cef_render_handler_t.on_popup_size_delegate bs_on_popup_size;
        private cef_render_handler_t.on_paint_delegate bs_on_paint;
        private cef_render_handler_t.on_cursor_change_delegate bs_on_cursor_change;

        protected CefRenderHandler()
        {
            this.refct = 0;
            this.ptr = cef_render_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get_view_rect = new cef_render_handler_t.get_view_rect_delegate(this.get_view_rect);
            this.ptr->get_view_rect = Marshal.GetFunctionPointerForDelegate(this.bs_get_view_rect);

            this.bs_get_screen_rect = new cef_render_handler_t.get_screen_rect_delegate(this.get_screen_rect);
            this.ptr->get_screen_rect = Marshal.GetFunctionPointerForDelegate(this.bs_get_screen_rect);

            this.bs_get_screen_point = new cef_render_handler_t.get_screen_point_delegate(this.get_screen_point);
            this.ptr->get_screen_point = Marshal.GetFunctionPointerForDelegate(this.bs_get_screen_point);

            this.bs_on_popup_show = new cef_render_handler_t.on_popup_show_delegate(this.on_popup_show);
            this.ptr->on_popup_show = Marshal.GetFunctionPointerForDelegate(this.bs_on_popup_show);

            this.bs_on_popup_size = new cef_render_handler_t.on_popup_size_delegate(this.on_popup_size);
            this.ptr->on_popup_size = Marshal.GetFunctionPointerForDelegate(this.bs_on_popup_size);

            this.bs_on_paint = new cef_render_handler_t.on_paint_delegate(this.on_paint);
            this.ptr->on_paint = Marshal.GetFunctionPointerForDelegate(this.bs_on_paint);

            this.bs_on_cursor_change = new cef_render_handler_t.on_cursor_change_delegate(this.on_cursor_change);
            this.ptr->on_cursor_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_cursor_change);

        }

        ~CefRenderHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, "~CefRenderHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_render_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefRenderHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_render_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_render_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefRenderHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefDragHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDragHandler> pointers = new ObjectTable<CefDragHandler>();



        private int refct;
        private cef_drag_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_drag_handler_t.on_drag_start_delegate bs_on_drag_start;
        private cef_drag_handler_t.on_drag_enter_delegate bs_on_drag_enter;

        protected CefDragHandler()
        {
            this.refct = 0;
            this.ptr = cef_drag_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDragHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_drag_start = new cef_drag_handler_t.on_drag_start_delegate(this.on_drag_start);
            this.ptr->on_drag_start = Marshal.GetFunctionPointerForDelegate(this.bs_on_drag_start);

            this.bs_on_drag_enter = new cef_drag_handler_t.on_drag_enter_delegate(this.on_drag_enter);
            this.ptr->on_drag_enter = Marshal.GetFunctionPointerForDelegate(this.bs_on_drag_enter);

        }

        ~CefDragHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDragHandler, this.ptr, "~CefDragHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDragHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_drag_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDragHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDragHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_drag_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_drag_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDragHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefClient : IDisposable
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefClient> pointers = new ObjectTable<CefClient>();

        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static CefClient From(cef_client_t* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, ptr, "From");
#endif
            if (ptr == null) throw new ArgumentNullException("ptr");
            CefClient value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("CefClient not found.");
            value.ReleaseRef();
            return value;
        }

        internal static CefClient FromOrDefault(cef_client_t* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, ptr, "FromOrDefault");
#endif
            if (ptr == null) return null;
            CefClient value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("CefClient not found.");
            value.ReleaseRef();
            return value;
        }


        private int refct;
        private cef_client_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_client_t.get_life_span_handler_delegate bs_get_life_span_handler;
        private cef_client_t.get_load_handler_delegate bs_get_load_handler;
        private cef_client_t.get_request_handler_delegate bs_get_request_handler;
        private cef_client_t.get_display_handler_delegate bs_get_display_handler;
        private cef_client_t.get_focus_handler_delegate bs_get_focus_handler;
        private cef_client_t.get_keyboard_handler_delegate bs_get_keyboard_handler;
        private cef_client_t.get_menu_handler_delegate bs_get_menu_handler;
        private cef_client_t.get_print_handler_delegate bs_get_print_handler;
        private cef_client_t.get_find_handler_delegate bs_get_find_handler;
        private cef_client_t.get_jsdialog_handler_delegate bs_get_jsdialog_handler;
        private cef_client_t.get_jsbinding_handler_delegate bs_get_jsbinding_handler;
        private cef_client_t.get_render_handler_delegate bs_get_render_handler;
        private cef_client_t.get_drag_handler_delegate bs_get_drag_handler;

        protected CefClient()
        {
            this.refct = 0;
            this.ptr = cef_client_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get_life_span_handler = new cef_client_t.get_life_span_handler_delegate(this.get_life_span_handler);
            this.ptr->get_life_span_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_life_span_handler);

            this.bs_get_load_handler = new cef_client_t.get_load_handler_delegate(this.get_load_handler);
            this.ptr->get_load_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_load_handler);

            this.bs_get_request_handler = new cef_client_t.get_request_handler_delegate(this.get_request_handler);
            this.ptr->get_request_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_request_handler);

            this.bs_get_display_handler = new cef_client_t.get_display_handler_delegate(this.get_display_handler);
            this.ptr->get_display_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_display_handler);

            this.bs_get_focus_handler = new cef_client_t.get_focus_handler_delegate(this.get_focus_handler);
            this.ptr->get_focus_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_focus_handler);

            this.bs_get_keyboard_handler = new cef_client_t.get_keyboard_handler_delegate(this.get_keyboard_handler);
            this.ptr->get_keyboard_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_keyboard_handler);

            this.bs_get_menu_handler = new cef_client_t.get_menu_handler_delegate(this.get_menu_handler);
            this.ptr->get_menu_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_menu_handler);

            this.bs_get_print_handler = new cef_client_t.get_print_handler_delegate(this.get_print_handler);
            this.ptr->get_print_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_print_handler);

            this.bs_get_find_handler = new cef_client_t.get_find_handler_delegate(this.get_find_handler);
            this.ptr->get_find_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_find_handler);

            this.bs_get_jsdialog_handler = new cef_client_t.get_jsdialog_handler_delegate(this.get_jsdialog_handler);
            this.ptr->get_jsdialog_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_jsdialog_handler);

            this.bs_get_jsbinding_handler = new cef_client_t.get_jsbinding_handler_delegate(this.get_jsbinding_handler);
            this.ptr->get_jsbinding_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_jsbinding_handler);

            this.bs_get_render_handler = new cef_client_t.get_render_handler_delegate(this.get_render_handler);
            this.ptr->get_render_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_render_handler);

            this.bs_get_drag_handler = new cef_client_t.get_drag_handler_delegate(this.get_drag_handler);
            this.ptr->get_drag_handler = Marshal.GetFunctionPointerForDelegate(this.bs_get_drag_handler);

        }

        ~CefClient()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, "~CefClient");
#endif
            Dispose(false);
        }

        public void Dispose()
        {
            if (this.RefCount == 0)
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
            else
            {
                this.disposed = true;
            }
        }

        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_client_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefClient, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_client_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_client_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefClient");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefReadHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefReadHandler> pointers = new ObjectTable<CefReadHandler>();



        private int refct;
        private cef_read_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_read_handler_t.read_delegate bs_read;
        private cef_read_handler_t.seek_delegate bs_seek;
        private cef_read_handler_t.tell_delegate bs_tell;
        private cef_read_handler_t.eof_delegate bs_eof;

        protected CefReadHandler()
        {
            this.refct = 0;
            this.ptr = cef_read_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_read = new cef_read_handler_t.read_delegate(this.read);
            this.ptr->read = Marshal.GetFunctionPointerForDelegate(this.bs_read);

            this.bs_seek = new cef_read_handler_t.seek_delegate(this.seek);
            this.ptr->seek = Marshal.GetFunctionPointerForDelegate(this.bs_seek);

            this.bs_tell = new cef_read_handler_t.tell_delegate(this.tell);
            this.ptr->tell = Marshal.GetFunctionPointerForDelegate(this.bs_tell);

            this.bs_eof = new cef_read_handler_t.eof_delegate(this.eof);
            this.ptr->eof = Marshal.GetFunctionPointerForDelegate(this.bs_eof);

        }

        ~CefReadHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, "~CefReadHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_read_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefReadHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_read_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_read_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefReadHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefWriteHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefWriteHandler> pointers = new ObjectTable<CefWriteHandler>();



        private int refct;
        private cef_write_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_write_handler_t.write_delegate bs_write;
        private cef_write_handler_t.seek_delegate bs_seek;
        private cef_write_handler_t.tell_delegate bs_tell;
        private cef_write_handler_t.flush_delegate bs_flush;

        protected CefWriteHandler()
        {
            this.refct = 0;
            this.ptr = cef_write_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_write = new cef_write_handler_t.write_delegate(this.write);
            this.ptr->write = Marshal.GetFunctionPointerForDelegate(this.bs_write);

            this.bs_seek = new cef_write_handler_t.seek_delegate(this.seek);
            this.ptr->seek = Marshal.GetFunctionPointerForDelegate(this.bs_seek);

            this.bs_tell = new cef_write_handler_t.tell_delegate(this.tell);
            this.ptr->tell = Marshal.GetFunctionPointerForDelegate(this.bs_tell);

            this.bs_flush = new cef_write_handler_t.flush_delegate(this.flush);
            this.ptr->flush = Marshal.GetFunctionPointerForDelegate(this.bs_flush);

        }

        ~CefWriteHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, "~CefWriteHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_write_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWriteHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_write_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_write_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefWriteHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefV8Handler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefV8Handler> pointers = new ObjectTable<CefV8Handler>();

        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static CefV8Handler From(cef_v8handler_t* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, ptr, "From");
#endif
            if (ptr == null) throw new ArgumentNullException("ptr");
            CefV8Handler value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("CefV8Handler not found.");
            value.ReleaseRef();
            return value;
        }

        internal static CefV8Handler FromOrDefault(cef_v8handler_t* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, ptr, "FromOrDefault");
#endif
            if (ptr == null) return null;
            CefV8Handler value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("CefV8Handler not found.");
            value.ReleaseRef();
            return value;
        }


        private int refct;
        private cef_v8handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_v8handler_t.execute_delegate bs_execute;

        protected CefV8Handler()
        {
            this.refct = 0;
            this.ptr = cef_v8handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_execute = new cef_v8handler_t.execute_delegate(this.execute);
            this.ptr->execute = Marshal.GetFunctionPointerForDelegate(this.bs_execute);

        }

        ~CefV8Handler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, "~CefV8Handler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_v8handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Handler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_v8handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_v8handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefV8Handler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefV8Accessor 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefV8Accessor> pointers = new ObjectTable<CefV8Accessor>();



        private int refct;
        private cef_v8accessor_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_v8accessor_t.get_delegate bs_get;
        private cef_v8accessor_t.set_delegate bs_set;

        protected CefV8Accessor()
        {
            this.refct = 0;
            this.ptr = cef_v8accessor_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_get = new cef_v8accessor_t.get_delegate(this.get);
            this.ptr->get = Marshal.GetFunctionPointerForDelegate(this.bs_get);

            this.bs_set = new cef_v8accessor_t.set_delegate(this.set);
            this.ptr->set = Marshal.GetFunctionPointerForDelegate(this.bs_set);

        }

        ~CefV8Accessor()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, "~CefV8Accessor");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_v8accessor_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefV8Accessor, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_v8accessor_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_v8accessor_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefV8Accessor");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefSchemeHandlerFactory 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefSchemeHandlerFactory> pointers = new ObjectTable<CefSchemeHandlerFactory>();



        private int refct;
        private cef_scheme_handler_factory_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_scheme_handler_factory_t.create_delegate bs_create;

        protected CefSchemeHandlerFactory()
        {
            this.refct = 0;
            this.ptr = cef_scheme_handler_factory_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_create = new cef_scheme_handler_factory_t.create_delegate(this.create);
            this.ptr->create = Marshal.GetFunctionPointerForDelegate(this.bs_create);

        }

        ~CefSchemeHandlerFactory()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, "~CefSchemeHandlerFactory");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_scheme_handler_factory_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandlerFactory, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_scheme_handler_factory_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_scheme_handler_factory_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefSchemeHandlerFactory");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefSchemeHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefSchemeHandler> pointers = new ObjectTable<CefSchemeHandler>();



        private int refct;
        private cef_scheme_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_scheme_handler_t.process_request_delegate bs_process_request;
        private cef_scheme_handler_t.get_response_headers_delegate bs_get_response_headers;
        private cef_scheme_handler_t.read_response_delegate bs_read_response;
        private cef_scheme_handler_t.cancel_delegate bs_cancel;

        protected CefSchemeHandler()
        {
            this.refct = 0;
            this.ptr = cef_scheme_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_process_request = new cef_scheme_handler_t.process_request_delegate(this.process_request);
            this.ptr->process_request = Marshal.GetFunctionPointerForDelegate(this.bs_process_request);

            this.bs_get_response_headers = new cef_scheme_handler_t.get_response_headers_delegate(this.get_response_headers);
            this.ptr->get_response_headers = Marshal.GetFunctionPointerForDelegate(this.bs_get_response_headers);

            this.bs_read_response = new cef_scheme_handler_t.read_response_delegate(this.read_response);
            this.ptr->read_response = Marshal.GetFunctionPointerForDelegate(this.bs_read_response);

            this.bs_cancel = new cef_scheme_handler_t.cancel_delegate(this.cancel);
            this.ptr->cancel = Marshal.GetFunctionPointerForDelegate(this.bs_cancel);

        }

        ~CefSchemeHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, "~CefSchemeHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_scheme_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefSchemeHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_scheme_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_scheme_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefSchemeHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefDownloadHandler 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDownloadHandler> pointers = new ObjectTable<CefDownloadHandler>();



        private int refct;
        private cef_download_handler_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_download_handler_t.received_data_delegate bs_received_data;
        private cef_download_handler_t.complete_delegate bs_complete;

        protected CefDownloadHandler()
        {
            this.refct = 0;
            this.ptr = cef_download_handler_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_received_data = new cef_download_handler_t.received_data_delegate(this.received_data);
            this.ptr->received_data = Marshal.GetFunctionPointerForDelegate(this.bs_received_data);

            this.bs_complete = new cef_download_handler_t.complete_delegate(this.complete);
            this.ptr->complete = Marshal.GetFunctionPointerForDelegate(this.bs_complete);

        }

        ~CefDownloadHandler()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, "~CefDownloadHandler");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_download_handler_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDownloadHandler, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_download_handler_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_download_handler_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDownloadHandler");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefWebUrlRequestClient 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefWebUrlRequestClient> pointers = new ObjectTable<CefWebUrlRequestClient>();



        private int refct;
        private cef_web_urlrequest_client_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_web_urlrequest_client_t.on_state_change_delegate bs_on_state_change;
        private cef_web_urlrequest_client_t.on_redirect_delegate bs_on_redirect;
        private cef_web_urlrequest_client_t.on_headers_received_delegate bs_on_headers_received;
        private cef_web_urlrequest_client_t.on_progress_delegate bs_on_progress;
        private cef_web_urlrequest_client_t.on_data_delegate bs_on_data;
        private cef_web_urlrequest_client_t.on_error_delegate bs_on_error;

        protected CefWebUrlRequestClient()
        {
            this.refct = 0;
            this.ptr = cef_web_urlrequest_client_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_on_state_change = new cef_web_urlrequest_client_t.on_state_change_delegate(this.on_state_change);
            this.ptr->on_state_change = Marshal.GetFunctionPointerForDelegate(this.bs_on_state_change);

            this.bs_on_redirect = new cef_web_urlrequest_client_t.on_redirect_delegate(this.on_redirect);
            this.ptr->on_redirect = Marshal.GetFunctionPointerForDelegate(this.bs_on_redirect);

            this.bs_on_headers_received = new cef_web_urlrequest_client_t.on_headers_received_delegate(this.on_headers_received);
            this.ptr->on_headers_received = Marshal.GetFunctionPointerForDelegate(this.bs_on_headers_received);

            this.bs_on_progress = new cef_web_urlrequest_client_t.on_progress_delegate(this.on_progress);
            this.ptr->on_progress = Marshal.GetFunctionPointerForDelegate(this.bs_on_progress);

            this.bs_on_data = new cef_web_urlrequest_client_t.on_data_delegate(this.on_data);
            this.ptr->on_data = Marshal.GetFunctionPointerForDelegate(this.bs_on_data);

            this.bs_on_error = new cef_web_urlrequest_client_t.on_error_delegate(this.on_error);
            this.ptr->on_error = Marshal.GetFunctionPointerForDelegate(this.bs_on_error);

        }

        ~CefWebUrlRequestClient()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, "~CefWebUrlRequestClient");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_web_urlrequest_client_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefWebUrlRequestClient, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_web_urlrequest_client_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_web_urlrequest_client_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefWebUrlRequestClient");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefDomVisitor 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDomVisitor> pointers = new ObjectTable<CefDomVisitor>();



        private int refct;
        private cef_domvisitor_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_domvisitor_t.visit_delegate bs_visit;

        protected CefDomVisitor()
        {
            this.refct = 0;
            this.ptr = cef_domvisitor_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_visit = new cef_domvisitor_t.visit_delegate(this.visit);
            this.ptr->visit = Marshal.GetFunctionPointerForDelegate(this.bs_visit);

        }

        ~CefDomVisitor()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, "~CefDomVisitor");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_domvisitor_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomVisitor, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_domvisitor_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_domvisitor_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDomVisitor");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefDomEventListener 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefDomEventListener> pointers = new ObjectTable<CefDomEventListener>();



        private int refct;
        private cef_domevent_listener_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_domevent_listener_t.handle_event_delegate bs_handle_event;

        protected CefDomEventListener()
        {
            this.refct = 0;
            this.ptr = cef_domevent_listener_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_handle_event = new cef_domevent_listener_t.handle_event_delegate(this.handle_event);
            this.ptr->handle_event = Marshal.GetFunctionPointerForDelegate(this.bs_handle_event);

        }

        ~CefDomEventListener()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, "~CefDomEventListener");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_domevent_listener_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefDomEventListener, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_domevent_listener_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_domevent_listener_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefDomEventListener");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefContentFilter 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefContentFilter> pointers = new ObjectTable<CefContentFilter>();



        private int refct;
        private cef_content_filter_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;
        private cef_content_filter_t.process_data_delegate bs_process_data;
        private cef_content_filter_t.drain_delegate bs_drain;

        protected CefContentFilter()
        {
            this.refct = 0;
            this.ptr = cef_content_filter_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

            this.bs_process_data = new cef_content_filter_t.process_data_delegate(this.process_data);
            this.ptr->process_data = Marshal.GetFunctionPointerForDelegate(this.bs_process_data);

            this.bs_drain = new cef_content_filter_t.drain_delegate(this.drain);
            this.ptr->drain = Marshal.GetFunctionPointerForDelegate(this.bs_drain);

        }

        ~CefContentFilter()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, "~CefContentFilter");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cef_content_filter_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefContentFilter, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cef_content_filter_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cef_content_filter_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefContentFilter");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }

    public abstract unsafe partial class CefUserData 
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<CefUserData> pointers = new ObjectTable<CefUserData>();

        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static CefUserData From(cefglue_userdata_t* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, ptr, "From");
#endif
            if (ptr == null) throw new ArgumentNullException("ptr");
            CefUserData value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("CefUserData not found.");
            value.ReleaseRef();
            return value;
        }

        internal static CefUserData FromOrDefault(cefglue_userdata_t* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, ptr, "FromOrDefault");
#endif
            if (ptr == null) return null;
            CefUserData value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("CefUserData not found.");
            value.ReleaseRef();
            return value;
        }


        private int refct;
        private cefglue_userdata_t* ptr;
        private bool disposed;

        private cef_base_t.add_ref_delegate bs_add_ref;
        private cef_base_t.release_delegate bs_release;
        private cef_base_t.get_refct_delegate bs_get_refct;

        protected CefUserData()
        {
            this.refct = 0;
            this.ptr = cefglue_userdata_t.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.Create);
#endif

            this.bs_add_ref = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.bs_add_ref);

            this.bs_release = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.bs_release);

            this.bs_get_refct = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.bs_get_refct);

        }

        ~CefUserData()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, "~CefUserData");
#endif
            Dispose(false);
        }


        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                cefglue_userdata_t.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
            }
        }

        protected object SyncRoot
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            var result = Interlocked.Increment(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.AddRef, "{0}", result);
            #endif
            if (result == 1)
            {
                pointers.Add((IntPtr)ptr, this);
            }
            return result;
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            var result = Interlocked.Decrement(ref this.refct);
            #if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.CefUserData, this.ptr, LogOperation.ReleaseRef, "{0}", result);
            #endif
            if (result == 0)
            {
                pointers.Remove((IntPtr)ptr);
            }
            return result;
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal cefglue_userdata_t* NativePointer
        {
            get { return this.ptr; }
        }

        internal cefglue_userdata_t* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("CefUserData");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }
}

