<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
void GenerateHandlerClasses()
{
#>//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
namespace CefGlue
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;
    using CefGlue.Interop;
    using CefGlue.Diagnostics;
<#+ foreach (var handler in this.HandlerSchema.Values) {
        GenerateHandlerClass(handler);
    } #>
}

<#+
}

void GenerateHandlerClass(HandlerDef def)
{
#>

    public abstract unsafe partial class <#=def.ClassName#> <#= def.Disposable ? ": IDisposable" : "" #>
    {
#if DIAGNOSTICS
        internal static int ObjectCt;
#endif

        private static ObjectTable<<#=def.ClassName#>> pointers = new ObjectTable<<#=def.ClassName#>>();

<#+ if (def.ReversibleNativePointer) { #>
        /// <summary>
        /// This is get object from pointer table, but note that this is works only when object passed to native side (i.e. RefCount > 0).
        /// </summary>
        internal static <#=def.ClassName#> From(<#=def.StructName#>* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, ptr, "From");
#endif
            if (ptr == null) throw new ArgumentNullException("ptr");
            <#=def.ClassName#> value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("<#=def.ClassName#> not found.");
            value.ReleaseRef();
            return value;
        }

        internal static <#=def.ClassName#> FromOrDefault(<#=def.StructName#>* ptr)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, ptr, "FromOrDefault");
#endif
            if (ptr == null) return null;
            <#=def.ClassName#> value;
            if (!pointers.TryGetValue((IntPtr)ptr, out value)) throw new CefException("<#=def.ClassName#> not found.");
            value.ReleaseRef();
            return value;
        }
<#+ } #>


        private int refct;
        private <#=def.StructName#>* ptr;
        private bool disposed;
        protected readonly object SyncRoot;

        private cef_base_t.add_ref_delegate <#=def.GetBackStoreName("add_ref")#>;
        private cef_base_t.release_delegate <#=def.GetBackStoreName("release")#>;
        private cef_base_t.get_refct_delegate <#=def.GetBackStoreName("get_refct")#>;
<#+ foreach(var cb in def.GetCallbacks()) { #>
        private <#=cb.DelegateName#> <#=cb.DelegateFieldName#>;
<#+ } #>

        protected <#=def.ClassName#>()
        {
            this.SyncRoot = new object();
            this.refct = 0;
            this.ptr = <#=def.StructName#>.Alloc();
#if DIAGNOSTICS
            Interlocked.Increment(ref ObjectCt);
#endif

#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Create);
#endif

            this.<#=def.GetBackStoreName("add_ref")#> = new cef_base_t.add_ref_delegate(this.add_ref);
            this.ptr->@base.add_ref = Marshal.GetFunctionPointerForDelegate(this.<#=def.GetBackStoreName("add_ref")#>);

            this.<#=def.GetBackStoreName("release")#> = new cef_base_t.release_delegate(this.release);
            this.ptr->@base.release = Marshal.GetFunctionPointerForDelegate(this.<#=def.GetBackStoreName("release")#>);

            this.<#=def.GetBackStoreName("get_refct")#> = new cef_base_t.get_refct_delegate(this.get_refct);
            this.ptr->@base.get_refct = Marshal.GetFunctionPointerForDelegate(this.<#=def.GetBackStoreName("get_refct")#>);

<#+ foreach (var cb in def.GetCallbacks()) { #>
            this.<#=cb.DelegateFieldName#> = new <#=cb.DelegateName#>(this.<#=cb.NativeCallbackName#>);
            this.ptr-><#=cb.ClientCallback ? cb.NativeCallbackName : cb.StructName#> = Marshal.GetFunctionPointerForDelegate(this.<#=cb.DelegateFieldName#>);

<#+ } #>
        }

        ~<#=def.ClassName#>()
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, "~<#=def.ClassName#>");
#endif
            Dispose(false);
        }

<#+ if (def.Disposable) { #>
        public void Dispose()
        {
            if (this.RefCount == 0)
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
            else
            {
                this.disposed = true;
            }
        }
<#+ } #>

        protected virtual void Dispose(bool disposing)
        {
#if DIAGNOSTICS
            Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.Dispose, "Disposing=[{0}]", disposing);
#endif

            this.disposed = true;

            if (this.ptr != null)
            {
#if DIAGNOSTICS
                Interlocked.Decrement(ref ObjectCt);
#endif
                <#=def.StructName#>.Free(this.ptr);
                this.ptr = null;
            }

            if (disposing)
            {
<#+ foreach(var cb in def.GetCallbacks()) { #>
<#+     if (cb.DisposeField) { #>
                if (<#=cb.FieldName#> != null) { <#=cb.FieldName#> = null; }
<#+     } #>
<#+ } #>
            }
        }

        /// <summary>
        /// The AddRef method increments the reference count for the object.
        /// It should be called for every new copy of a pointer to a given object.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int AddRef()
        {
            lock (this.SyncRoot)
            {
                var result = ++this.refct;
                #if DIAGNOSTICS
                Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.AddRef, "{0}", result);
                #endif
                if (result == 1)
                {
                    pointers.Add((IntPtr)ptr, this);
                }
                return result;
            }
        }

        /// <summary>
        /// The Release method decrements the reference count for the object.
        /// If the reference count on the object falls to 0, then the object should free itself from memory.
        /// The resulting reference count value is returned and should be used for diagnostic/testing purposes only.
        /// </summary>
        internal int ReleaseRef(bool disposing = true)
        {
            lock (this.SyncRoot)
            {
                var result = --this.refct;
                #if DIAGNOSTICS
                Cef.Logger.Trace(LogTarget.<#=def.ClassName#>, this.ptr, LogOperation.ReleaseRef, "{0}", result);
                #endif
                if (result == 0)
                {
                    pointers.Remove((IntPtr)ptr);
                }
                return result;
            }
        }

        /// <summary>
        /// Return the current number of references.
        /// </summary>
        internal int RefCount
        {
            get { return this.refct; }
        }

        internal <#=def.StructName#>* NativePointer
        {
            get { return this.ptr; }
        }

        internal <#=def.StructName#>* GetNativePointerAndAddRef()
        {
            AddRef();
            return this.ptr;
        }

        private int add_ref(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return AddRef();
        }

        private int release(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return ReleaseRef();
        }

        private int get_refct(cef_base_t* self)
        {
            ThrowIfObjectDisposed();
            return RefCount;
        }

        protected void ThrowIfObjectDisposed()
        {
            if (this.disposed) ThrowObjectDisposedException();
        }

        private static void ThrowObjectDisposedException()
        {
            throw new ObjectDisposedException("<#=def.ClassName#>");
        }

        [Conditional("DEBUG")]
        private void CheckNativePointer()
        {
            if (this.ptr == null) ThrowObjectDisposedException();
        }
    }
<#+
}
#>
